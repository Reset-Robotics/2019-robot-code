import edu.wpi.first.gradlerio.GradleRIOPlugin
import edu.wpi.first.gradlerio.frc.FRCJavaArtifact
import edu.wpi.first.gradlerio.frc.RoboRIO
import com.cisco.gradle.externalbuild.ExternalNativeLibrarySpec
import com.cisco.gradle.externalbuild.tasks.CMake


plugins {
    id "java"
    id "org.jetbrains.kotlin.jvm" version "1.3.11"
    id "edu.wpi.first.GradleRIO" version "2019.1.1"
    id "jaci.gradle.EmbeddedTools" version "2018.12.18"
    id 'com.cisco.external-build' version '1.10'
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"
def getIntermediateDir = { binary ->
    file("${buildDir}/external-build/${binary.component.name}/${binary.targetPlatform.name}")
}

def getInstallDir = { binary ->
    file("${buildDir}/install/${binary.component.name}/${binary.targetPlatform.name}")
}


ext.kotlinVersion = "1.3.11"
ext.sertainVersion = "a2c505171b318836e0619b3c25dabae3a7857bf5"
//ext.sertainVersion = "5c9ab17c739b4b4791a3f7142b20112df41a43d8"
ext.ktlintVersion = "0.19.0"

check.dependsOn "ktlint"
tasks.whenTaskAdded { task ->
    if (task.name == "deploy" || task.name == "deployMain") task.dependsOn "assemble"
}


// Maven central needed for JUnit
repositories {
    google()
    jcenter()
    maven { url "https://jitpack.io" }
}

configurations {
    ktlint
}

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 4.
dependencies {
    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"
    compile "org.sert2521.sertain:core:$sertainVersion"
    ktlint "com.github.shyiko:ktlint:$ktlintVersion"

    compile fileTree(include: ['*.jar'], dir: 'jars')

    compile wpi.deps.wpilib()
    compile wpi.deps.vendor.java()
    nativeZip wpi.deps.vendor.jni(wpi.platforms.roborio)
    nativeDesktopZip wpi.deps.vendor.jni(wpi.platforms.desktop)
    testCompile 'junit:junit:4.12'
}

compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
}

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project EmbeddedTools.
deploy {
    targets {
        // Rio co-processor target
        roboRIO("roborio") {
            // Team number is loaded either from the .wpilib/wpilib_preferences.json
            // or from command line. If not found an exception will be thrown.
            // You can use getTeamOrDefault(team) instead of getTeamNumber if you
            // want to store a team number in this file.
            team = frc.getTeamOrDefault(6325)
        }

        // Jetson co-processor target
        target("jetson") {
            directory = '/home/6325/Jetson' 
            maxChannels = 1
            timeout = 30
            failOnMissing = true
            
            locations {
                ssh {
                    address = "nvidia@tegra-ubuntu"
                    user = 'nvidia'
                    password = 'nvidia'
                    ipv6 = false
                }
            }
                       
        }
    }
    artifacts {
        // Rio co-processor artifact
        frcJavaArtifact('frcJava') {
            targets << "roborio"
            // Debug can be overridden by command line, for use with VSCode
            debug = frc.getDebugOrDefault(false)
        }
        // Built in artifact to deploy arbitrary files to the roboRIO.
        fileTreeArtifact('frcStaticFileDeploy') {
            // The directory below is the local directory to deploy
            files = fileTree(dir: 'src/main/deploy')
            // Deploy to RoboRIO target, into /home/lvuser/deploy
            targets << "roborio"
            directory = '/home/lvuser/deploy'
        }

        // Jetson co-processor artifact
        artifact('jetsonArtifact') {
            directory = '/home/6325/Jetson'
            targets << "jetson"
        }

        // Jetson co-processor file deploy artifact
        fileArtifact('jetsonFileDeploy') {
            file = file('ahoy22')
            filename = 'ahoy22.exe'
        }
    }
}

model {
    components {
        jetson(ExternalNativeExecutableSpec) {
            buildConfig(CMake) {
                def intDir = getIntermediateDir(binary)
                def outputDir = getInstallDir(binary)

                cmakeRoot '.'
                cmakeArgs "-DCMAKE_INSTALL_PREFIX=${outputDir}"
                targets 'all', 'install'

                inputs.dir 'src/Jetson'
                inputs.file 'CMakeLists.txt'
                outputs.dir outputDir

                workingDir intDir
                environment = [
                    'PATH': toolChainPath,
                ]
            }

            buildOutput {
                def outputDir = getInstallDir(binary)
                outputFile = file("${outputDir}/bin/jetson")
            }
        }
    }
}

/* Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
in order to make them all available at runtime. Also adding the manifest so WPILib
knows where to look for our Robot Class. */
jar {
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
}

task ktlint(type: JavaExec) {
    main = "com.github.shyiko.ktlint.Main"
    classpath = configurations.ktlint
    args "src/**/*.kt"
}

wrapper {
    gradleVersion = "5.1"
}
